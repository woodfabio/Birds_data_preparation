for(i in 1:max(groups)) {
CORCEN[i,1] <- mean(shortSITES[which(groups==i),3])
CORCEN[i,2] <- mean(shortSITES[which(groups==i),4])
}
# Acrescentar centroides no grafico:
points(CORCEN,pch=4,cex=0.5)
# Lista de nomes dos sitios:
sitel <- sort(unique(SEGMTS$Spot))
# Numero de sitios:
nsites <- length(unique(sitel))
# Numero de grupos de sitios:
ngroups <- length(table(groups))
# Vetor de vetores de grupos onde cada vetor de grupo possui todos os sitios
# pertencentes a este grupo:
sitegroup <- as.vector(rep(list(rep(NA, max(table(groups)))), ngroups))
for (i in 1:length(sitegroup)) { sitegroup[[i]] <- shortSITES[which(groups==i),1] }
# Lista de nomes de grupos(o nome de cada grupo eh o nome do primeiro sitio
# daquele grupo):
groupl <- rep(NA,ngroups)
for(i in 1:ngroups) {groupl[i]<-sitegroup[[i]][1]}
# Lista de anos:
yearl <- sort(unique(floor(SEGMTS$Date/10000)))
# Lista de datas:
datel <- as.Date(as.character(SEGMTS$Date), format = "%Y%m%d")
# Obter o numero maximo de dias de amostragem em cada ano baseado nos grupos:
yrgroup <- matrix(rep(NA,ngroups*length(yearl)),ncol=length(yearl))
for(i in 1:ngroups) {
yrgroup[i,] <- tabulate(floor(sort(unique(SEGMTS$Date[which(SEGMTS$Spot %in% sitegroup[[i]])]))/10000)-2009, nbins=5)
}
maxdy <- apply(yrgroup,2,max)
# Tabela 1 - numero de deteccoes por grupo e dia:
NDETSG <- array(data=NA,dim=c(ngroups,sum(maxdy),nsps))
dimnames(NDETSG)[[3]] <- colnames(Y)
# Datas dos dias de amostragem por sitio ao longo dos anos:
DATSG <- t(matrix(data=NA,nrow=ngroups,ncol=sum(maxdy)))
DATSG <- data.frame(DATSG)
for(i in 1:ngroups) {class(DATSG[,i])="Date"}
# Esforço (minutos de gravacao) por dia e por grupo:
EFFGmins <- matrix(data=NA,nrow=ngroups,ncol=sum(maxdy))
# Esforço (numero de sitios amostrados) por dia e por grupo:
EFFGsits <- matrix(data=NA,nrow=ngroups,ncol=sum(maxdy))
for(i in 1:1) {  # 1:nsps
cat("especie =",i,"\n")
# pegar a coluna correspondente a especie da vez
colsp <- which(colnames(Y)==cspecies[i])
# definir o ano da vez
for(j in 2:2) { # 1:length(yearl)
cat("ano =",j,"\n")
cy <- yearl[j] # "cy" = "current year"
# definir o grupo da vez
for(k in 1:ngroups) {
cat("\nespecie = ", i, "\nano = ", j, "\ngrupo =",k,"\n", "\n-------------")
cg <- sitegroup[[k]] # "cg" = "current group"
# definir datas correspondentes ao grupo e ano da vez:
cdg <- sort(unique(datel[which(SEGMTS$Spot%in%cg & format(datel,'%Y')==cy)])) # "cdg" = "current day group"
# pular para o proximo grupo se nao houver dias amostrados no "cy":
if(length(cdg)==0) next
# calcular o fdc (first day column), ou seja, a primeira coluna a ser
# preenchida (referente ao primero dia daquele ano):
if(j==1) { fdc <- 1 } else { fdc<-sum(maxdy[1:(j-1)])+1 }
# guardar as datas em "DATSG":
if (i == 1) { # se for o loop da primeira especie
DATSG[fdc:(fdc+length(cdg)-1),k] <- cdg
}
# guardar o esforco e o numero de deteccoes, respectivamente,
# nas matrizes de esforco e no NDETSG:
for(l in 1:length(cdg)) {
cd <- cdg[l] # "cd" = "current day"
# guardar esforco em minutos em "EFFGmins":
EFFGmins[k,(fdc+l-1)] <- length(which(SEGMTS$Spot%in%cg & datel==cd))
# guardar esforco em numero de sitios em "EFFGsits":
EFFGsits[k,(fdc+l-1)] <- length(unique(SEGMTS$Spot[which(SEGMTS$Spot%in%cg & datel==cd)]))
# guardar o numero de deteccoes em NDETSG:
ndet <- sum(datel==cd & SEGMTS$Spot%in%cg & Y[,colsp]>thr,na.rm=TRUE)
NDETSG[k, fdc+l-1, i] <- ndet
} # l dates
} # k sites
} # j years
} # i species
tail(NDETSG)
tail(NDETSG[,,1])
tail(NDETSG[,,1])
tail(oldNDETSG[,,1])
tail(shortNDETSG[,,1])
head(shortNDETSG[,,1])
head(oldNDETSG[,,1])
head(shortSITES)
View(Y)
dim(Y)
dim(SITES)
dim(SEGMTS)
head(SEGMTS)
tail(SEGMTS)
# Tabela 1 - numero de deteccoes por grupo e dia:
NDETSG <- array(data=NA,dim=c(ngroups,sum(maxdy),nsps))
dimnames(NDETSG)[[3]] <- colnames(Y)
# Datas dos dias de amostragem por sitio ao longo dos anos:
DATSG <- t(matrix(data=NA,nrow=ngroups,ncol=sum(maxdy)))
DATSG <- data.frame(DATSG)
for(i in 1:ngroups) {class(DATSG[,i])="Date"}
# Esforço (minutos de gravacao) por dia e por grupo:
EFFGmins <- matrix(data=NA,nrow=ngroups,ncol=sum(maxdy))
# Esforço (numero de sitios amostrados) por dia e por grupo:
EFFGsits <- matrix(data=NA,nrow=ngroups,ncol=sum(maxdy))
for(i in 1:1) {
cat("especie =",i,"\n")
# pegar a coluna correspondente a especie da vez
colsp <- i
# definir o ano da vez
for(j in 1:1) {
cat("ano =",j,"\n")
cy <- yearl[j] # "cy" = "current year"
# definir o grupo da vez
for(k in 1:ngroups) {
cat("\nespecie = ", i, "\nano = ", j, "\ngrupo =",k,"\n", "\n-------------")
cg <- sitegroup[[k]] # "cg" = "current group"
# definir datas correspondentes ao grupo e ano da vez:
cdg <- sort(unique(datel[which(SEGMTS$Spot%in%cg & format(datel,'%Y')==cy)])) # "cdg" = "current day group"
# pular para o proximo grupo se nao houver dias amostrados no "cy":
if(length(cdg)==0) next
# calcular o fdc (first day column), ou seja, a primeira coluna a ser
# preenchida (referente ao primero dia daquele ano):
if(j==1) { fdc <- 1 } else { fdc<-sum(maxdy[1:(j-1)])+1 }
# guardar as datas em "DATSG":
if (i == 1) { # se for o loop da primeira especie
DATSG[fdc:(fdc+length(cdg)-1),k] <- cdg
}
# guardar o esforco e o numero de deteccoes, respectivamente,
# nas matrizes de esforco e no NDETSG:
for(l in 1:length(cdg)) {
cd <- cdg[l] # "cd" = "current day"
# guardar esforco em minutos em "EFFGmins":
EFFGmins[k,(fdc+l-1)] <- length(which(SEGMTS$Spot%in%cg & datel==cd))
# guardar esforco em numero de sitios em "EFFGsits":
EFFGsits[k,(fdc+l-1)] <- length(unique(SEGMTS$Spot[which(SEGMTS$Spot%in%cg & datel==cd)]))
# guardar o numero de deteccoes em NDETSG:
ndet <- sum(datel==cd & SEGMTS$Spot%in%cg & Y[,colsp]>thr,na.rm=TRUE)
NDETSG[k, fdc+l-1, i] <- ndet
} # l dates
} # k sites
} # j years
} # i species
head(NDETSG)
head(NDETSG[,,1])
head(shortNDETSG[,,1])
any(shortNDETSG != NDETSG)
any(shortNDETSG != NDETSG, na.rm = TRUE)
nsps
# Numero de especies:
nsps <- length(colnames(Y))
nsps
i
cy
head(shortNDETSG[,,1])
tail(shortNDETSG[,,1])
## Carregar dados
load("/Users/gferraz/OneDrive/Projects/NSpsOccDynManaus/Data Processing/Data/DadosDiurnas_PDBFF.RData")
load("C:/Users/fabio/OneDrive/NSpsOccDynManaus/Data Processing/Data/DadosDiurnas_PDBFF.RData")
oldY <- Y
Y <- Y[2000:nrow(Y),,]
# "SEGMTS" eh um arquivo CSV cujas dimensoes sao:
# - Linhas: trechos de gravacao
# - Colunas: dados de cada trecho de gravacao (sitio, data, numero do bloco de
#            gravacao e numero do trecho)
SEGMTS <- read.csv("../Data_input/date_time_diurnal_capitalization_r.txt", head=TRUE, sep=",")
# "SITES" eh um arquivo CSV cujas dimensoes sao:
# - Linhas: sitios
# - Colunas: dados de cada sitio (nome, tipo de floresta (flor. primária = 0,
#            flor. secundária = 1), coordenadas geograficas (X e Y))
SITES <- read.csv("../Data_input/locations_diurnal_capitalization_r.txt", head=TRUE, sep="\t")
# Numero de especies:
nsps <- length(colnames(Y))
# Threshold para filtrar probabiliades de presenca de vocalizacao no trecho de
# gravacao:
thr <- 0.9
# Como "SEGMTS" nao possui informacoes de amostragem sobre todos os sitios
# presentes em "SITES", precisamos filtrar a lista de sitios incluindo somente
# os que aparecem em "SEGMTS":
shortSITES<-SITES[which(SITES$Spot %in% SEGMTS$Spot),]
# Definir distancia maxima em metros necessaria para que dois sitios sejam
# considerados do mesmo cluster (grupo).
## Isto nao impede que alguns pontos dentro do mesmo cluster tenham
## uma distancia maior que a mínima entre si:
dmin <- 110
# Obter grupos pelo método "single" que agrupa com base na distancia maxima
# entre pontos de cada cluster e gravar num objeto de dendrograma:
dendrog <- hclust(dist(shortSITES[,3:4]), method="single")
# Plotar:
plot(dendrog,hang=-1)
# Formar vetor de grupos de sitios com base no dendrograma:
groups <- cutree(dendrog,h=dmin)
# Plotar representando os grupos com cores:
plot(shortSITES[,3:4],col=groups)
# Criar matriz de coordenadas de centroide de grupo com tantas linhas quantos
# grupos:
CORCEN <- matrix(NA,nrow=max(groups),ncol=2)
for(i in 1:max(groups)) {
CORCEN[i,1] <- mean(shortSITES[which(groups==i),3])
CORCEN[i,2] <- mean(shortSITES[which(groups==i),4])
}
# Acrescentar centroides no grafico:
points(CORCEN,pch=4,cex=0.5)
# Lista de nomes dos sitios:
sitel <- sort(unique(SEGMTS$Spot))
# Numero de sitios:
nsites <- length(unique(sitel))
# Numero de grupos de sitios:
ngroups <- length(table(groups))
# Vetor de vetores de grupos onde cada vetor de grupo possui todos os sitios
# pertencentes a este grupo:
sitegroup <- as.vector(rep(list(rep(NA, max(table(groups)))), ngroups))
for (i in 1:length(sitegroup)) { sitegroup[[i]] <- shortSITES[which(groups==i),1] }
# Lista de nomes de grupos(o nome de cada grupo eh o nome do primeiro sitio
# daquele grupo):
groupl <- rep(NA,ngroups)
for(i in 1:ngroups) {groupl[i]<-sitegroup[[i]][1]}
# Lista de anos:
yearl <- sort(unique(floor(SEGMTS$Date/10000)))
# Lista de datas:
datel <- as.Date(as.character(SEGMTS$Date), format = "%Y%m%d")
# Obter o numero maximo de dias de amostragem em cada ano baseado nos grupos:
yrgroup <- matrix(rep(NA,ngroups*length(yearl)),ncol=length(yearl))
for(i in 1:ngroups) {
yrgroup[i,] <- tabulate(floor(sort(unique(SEGMTS$Date[which(SEGMTS$Spot %in% sitegroup[[i]])]))/10000)-2009, nbins=5)
}
maxdy <- apply(yrgroup,2,max)
# Tabela 1 - numero de deteccoes por grupo e dia:
NDETSG <- array(data=NA,dim=c(ngroups,sum(maxdy),nsps))
dimnames(NDETSG)[[3]] <- colnames(Y)
# Datas dos dias de amostragem por sitio ao longo dos anos:
DATSG <- t(matrix(data=NA,nrow=ngroups,ncol=sum(maxdy)))
DATSG <- data.frame(DATSG)
for(i in 1:ngroups) {class(DATSG[,i])="Date"}
# Esforço (minutos de gravacao) por dia e por grupo:
EFFGmins <- matrix(data=NA,nrow=ngroups,ncol=sum(maxdy))
# Esforço (numero de sitios amostrados) por dia e por grupo:
EFFGsits <- matrix(data=NA,nrow=ngroups,ncol=sum(maxdy))
for(i in 1:1) {
cat("especie =",i,"\n")
# pegar a coluna correspondente a especie da vez
# definir o ano da vez
for(j in 1:1) {
cat("ano =",j,"\n")
cy <- yearl[j] # "cy" = "current year"
# definir o grupo da vez
for(k in 1:ngroups) {
cat("\nespecie = ", i, "\nano = ", j, "\ngrupo =",k,"\n", "\n-------------")
cg <- sitegroup[[k]] # "cg" = "current group"
# definir datas correspondentes ao grupo e ano da vez:
cdg <- sort(unique(datel[which(SEGMTS$Spot%in%cg & format(datel,'%Y')==cy)])) # "cdg" = "current day group"
# pular para o proximo grupo se nao houver dias amostrados no "cy":
if(length(cdg)==0) next
# calcular o fdc (first day column), ou seja, a primeira coluna a ser
# preenchida (referente ao primero dia daquele ano):
if(j==1) { fdc <- 1 } else { fdc<-sum(maxdy[1:(j-1)])+1 }
# guardar as datas em "DATSG":
if (i == 1) { # se for o loop da primeira especie
DATSG[fdc:(fdc+length(cdg)-1),k] <- cdg
}
# guardar o esforco e o numero de deteccoes, respectivamente,
# nas matrizes de esforco e no NDETSG:
for(l in 1:length(cdg)) {
cd <- cdg[l] # "cd" = "current day"
# guardar esforco em minutos em "EFFGmins":
EFFGmins[k,(fdc+l-1)] <- length(which(SEGMTS$Spot%in%cg & datel==cd))
# guardar esforco em numero de sitios em "EFFGsits":
EFFGsits[k,(fdc+l-1)] <- length(unique(SEGMTS$Spot[which(SEGMTS$Spot%in%cg & datel==cd)]))
# guardar o numero de deteccoes em NDETSG:
ndet <- sum(datel==cd & SEGMTS$Spot%in%cg & Y[,i]>thr,na.rm=TRUE)
NDETSG[k, fdc+l-1, i] <- ndet
} # l dates
} # k sites
} # j years
} # i species
dim(Y)
Y <- oldY[(nrow(Y)-2000):nrow(Y),]
# Tabela 1 - numero de deteccoes por grupo e dia:
NDETSG <- array(data=NA,dim=c(ngroups,sum(maxdy),nsps))
dimnames(NDETSG)[[3]] <- colnames(Y)
# Datas dos dias de amostragem por sitio ao longo dos anos:
DATSG <- t(matrix(data=NA,nrow=ngroups,ncol=sum(maxdy)))
DATSG <- data.frame(DATSG)
for(i in 1:ngroups) {class(DATSG[,i])="Date"}
# Esforço (minutos de gravacao) por dia e por grupo:
EFFGmins <- matrix(data=NA,nrow=ngroups,ncol=sum(maxdy))
# Esforço (numero de sitios amostrados) por dia e por grupo:
EFFGsits <- matrix(data=NA,nrow=ngroups,ncol=sum(maxdy))
for(i in 1:1) {
cat("especie =",i,"\n")
# pegar a coluna correspondente a especie da vez
# definir o ano da vez
for(j in 1:1) {
cat("ano =",j,"\n")
cy <- yearl[j] # "cy" = "current year"
# definir o grupo da vez
for(k in 1:ngroups) {
cat("\nespecie = ", i, "\nano = ", j, "\ngrupo =",k,"\n", "\n-------------")
cg <- sitegroup[[k]] # "cg" = "current group"
# definir datas correspondentes ao grupo e ano da vez:
cdg <- sort(unique(datel[which(SEGMTS$Spot%in%cg & format(datel,'%Y')==cy)])) # "cdg" = "current day group"
# pular para o proximo grupo se nao houver dias amostrados no "cy":
if(length(cdg)==0) next
# calcular o fdc (first day column), ou seja, a primeira coluna a ser
# preenchida (referente ao primero dia daquele ano):
if(j==1) { fdc <- 1 } else { fdc<-sum(maxdy[1:(j-1)])+1 }
# guardar as datas em "DATSG":
if (i == 1) { # se for o loop da primeira especie
DATSG[fdc:(fdc+length(cdg)-1),k] <- cdg
}
# guardar o esforco e o numero de deteccoes, respectivamente,
# nas matrizes de esforco e no NDETSG:
for(l in 1:length(cdg)) {
cd <- cdg[l] # "cd" = "current day"
# guardar esforco em minutos em "EFFGmins":
EFFGmins[k,(fdc+l-1)] <- length(which(SEGMTS$Spot%in%cg & datel==cd))
# guardar esforco em numero de sitios em "EFFGsits":
EFFGsits[k,(fdc+l-1)] <- length(unique(SEGMTS$Spot[which(SEGMTS$Spot%in%cg & datel==cd)]))
# guardar o numero de deteccoes em NDETSG:
ndet <- sum(datel==cd & SEGMTS$Spot%in%cg & Y[,i]>thr,na.rm=TRUE)
NDETSG[k, fdc+l-1, i] <- ndet
} # l dates
} # k sites
} # j years
} # i species
nrow(oldY)
nrow(oldY)-2000
dim(Y)
head(NDETSG)
head(NDETSG[,,1])
write.table(Y, "../Data_input/shortY.csv", sep = ";", row.names=FALSE, quote=FALSE)
# "shortY" eh um arquivo CSV cujas dimensoes sao:
#   - Linhas: trechos de gravacao
#   - Colunas: especies
# onde cada celula possui a probabilidade de presença da vocalizacao daquela
# especie naquele trecho
# "shortY" eh uma amostra das 2000 ultimas linhas do dataset original
Y <- read.csv("../Data_input/shortY.csv", head=TRUE, sep=";")
# "SEGMTS" eh um arquivo CSV cujas dimensoes sao:
# - Linhas: trechos de gravacao
# - Colunas: dados de cada trecho de gravacao (sitio, data, numero do bloco de
#            gravacao e numero do trecho)
SEGMTS <- read.csv("../Data_input/date_time_diurnal_capitalization_r.txt", head=TRUE, sep=",")
# "SITES" eh um arquivo CSV cujas dimensoes sao:
# - Linhas: sitios
# - Colunas: dados de cada sitio (nome, tipo de floresta (flor. primária = 0,
#            flor. secundária = 1), coordenadas geograficas (X e Y))
SITES <- read.csv("../Data_input/locations_diurnal_capitalization_r.txt", head=TRUE, sep="\t")
# Numero de especies:
nsps <- length(colnames(Y))
# Threshold para filtrar probabiliades de presenca de vocalizacao no trecho de
# gravacao:
thr <- 0.9
# Como "SEGMTS" nao possui informacoes de amostragem sobre todos os sitios
# presentes em "SITES", precisamos filtrar a lista de sitios incluindo somente
# os que aparecem em "SEGMTS":
shortSITES<-SITES[which(SITES$Spot %in% SEGMTS$Spot),]
# Definir distancia maxima em metros necessaria para que dois sitios sejam
# considerados do mesmo cluster (grupo).
## Isto nao impede que alguns pontos dentro do mesmo cluster tenham
## uma distancia maior que a mínima entre si:
dmin <- 110
# Obter grupos pelo método "single" que agrupa com base na distancia maxima
# entre pontos de cada cluster e gravar num objeto de dendrograma:
dendrog <- hclust(dist(shortSITES[,3:4]), method="single")
# Plotar:
plot(dendrog,hang=-1)
# Formar vetor de grupos de sitios com base no dendrograma:
groups <- cutree(dendrog,h=dmin)
# Plotar representando os grupos com cores:
plot(shortSITES[,3:4],col=groups)
# Criar matriz de coordenadas de centroide de grupo com tantas linhas quantos
# grupos:
CORCEN <- matrix(NA,nrow=max(groups),ncol=2)
for(i in 1:max(groups)) {
CORCEN[i,1] <- mean(shortSITES[which(groups==i),3])
CORCEN[i,2] <- mean(shortSITES[which(groups==i),4])
}
# Acrescentar centroides no grafico:
points(CORCEN,pch=4,cex=0.5)
# Lista de nomes dos sitios:
sitel <- sort(unique(SEGMTS$Spot))
# Numero de sitios:
nsites <- length(unique(sitel))
# Numero de grupos de sitios:
ngroups <- length(table(groups))
# "shortY" eh um arquivo CSV cujas dimensoes sao:
#   - Linhas: trechos de gravacao
#   - Colunas: especies
# onde cada celula possui a probabilidade de presença da vocalizacao daquela
# especie naquele trecho
# "shortY" eh uma amostra das 2000 ultimas linhas do dataset original
Y <- read.csv("../Data_input/shortY.csv", head=TRUE, sep=";")
# "SEGMTS" eh um arquivo CSV cujas dimensoes sao:
# - Linhas: trechos de gravacao
# - Colunas: dados de cada trecho de gravacao (sitio, data, numero do bloco de
#            gravacao e numero do trecho)
SEGMTS <- read.csv("../Data_input/date_time_diurnal_capitalization_r.txt", head=TRUE, sep=",")
# "SITES" eh um arquivo CSV cujas dimensoes sao:
# - Linhas: sitios
# - Colunas: dados de cada sitio (nome, tipo de floresta (flor. primária = 0,
#            flor. secundária = 1), coordenadas geograficas (X e Y))
SITES <- read.csv("../Data_input/locations_diurnal_capitalization_r.txt", head=TRUE, sep="\t")
# Numero de especies:
nsps <- length(colnames(Y))
# Threshold para filtrar probabiliades de presenca de vocalizacao no trecho de
# gravacao:
thr <- 0.9
# Como "SEGMTS" nao possui informacoes de amostragem sobre todos os sitios
# presentes em "SITES", precisamos filtrar a lista de sitios incluindo somente
# os que aparecem em "SEGMTS":
shortSITES<-SITES[which(SITES$Spot %in% SEGMTS$Spot),]
# Definir distancia maxima em metros necessaria para que dois sitios sejam
# considerados do mesmo cluster (grupo).
## Isto nao impede que alguns pontos dentro do mesmo cluster tenham
## uma distancia maior que a mínima entre si:
dmin <- 110
# Obter grupos pelo método "single" que agrupa com base na distancia maxima
# entre pontos de cada cluster e gravar num objeto de dendrograma:
dendrog <- hclust(dist(shortSITES[,3:4]), method="single")
# Plotar:
plot(dendrog,hang=-1)
# Formar vetor de grupos de sitios com base no dendrograma:
groups <- cutree(dendrog,h=dmin)
# Plotar representando os grupos com cores:
plot(shortSITES[,3:4],col=groups)
# Criar matriz de coordenadas de centroide de grupo com tantas linhas quantos
# grupos:
CORCEN <- matrix(NA,nrow=max(groups),ncol=2)
for(i in 1:max(groups)) {
CORCEN[i,1] <- mean(shortSITES[which(groups==i),3])
CORCEN[i,2] <- mean(shortSITES[which(groups==i),4])
}
# Acrescentar centroides no grafico:
points(CORCEN,pch=4,cex=0.5)
# Lista de nomes dos sitios:
sitel <- sort(unique(SEGMTS$Spot))
# Numero de sitios:
nsites <- length(unique(sitel))
# Numero de grupos de sitios:
ngroups <- length(table(groups))
# Vetor de vetores de grupos onde cada vetor de grupo possui todos os sitios
# pertencentes a este grupo:
sitegroup <- as.vector(rep(list(rep(NA, max(table(groups)))), ngroups))
for (i in 1:length(sitegroup)) { sitegroup[[i]] <- shortSITES[which(groups==i),1] }
# Lista de nomes de grupos(o nome de cada grupo eh o nome do primeiro sitio
# daquele grupo):
groupl <- rep(NA,ngroups)
for(i in 1:ngroups) {groupl[i]<-sitegroup[[i]][1]}
# Lista de anos:
yearl <- sort(unique(floor(SEGMTS$Date/10000)))
# Lista de datas:
datel <- as.Date(as.character(SEGMTS$Date), format = "%Y%m%d")
# Obter o numero maximo de dias de amostragem em cada ano baseado nos grupos:
yrgroup <- matrix(rep(NA,ngroups*length(yearl)),ncol=length(yearl))
for(i in 1:ngroups) {
yrgroup[i,] <- tabulate(floor(sort(unique(SEGMTS$Date[which(SEGMTS$Spot %in% sitegroup[[i]])]))/10000)-2009, nbins=5)
}
maxdy <- apply(yrgroup,2,max)
# Tabela 1 - numero de deteccoes por grupo e dia:
NDETSG <- array(data=NA,dim=c(ngroups,sum(maxdy),nsps))
# Tabela 1 - numero de deteccoes por grupo e dia:
NDETSG <- array(data=NA,dim=c(ngroups,sum(maxdy),nsps))
dimnames(NDETSG)[[3]] <- colnames(Y)
# Datas dos dias de amostragem por sitio ao longo dos anos:
DATSG <- t(matrix(data=NA,nrow=ngroups,ncol=sum(maxdy)))
DATSG <- data.frame(DATSG)
for(i in 1:ngroups) {class(DATSG[,i])="Date"}
# Esforço (minutos de gravacao) por dia e por grupo:
EFFGmins <- matrix(data=NA,nrow=ngroups,ncol=sum(maxdy))
# Esforço (numero de sitios amostrados) por dia e por grupo:
EFFGsits <- matrix(data=NA,nrow=ngroups,ncol=sum(maxdy))
for(i in 1:1) {
cat("especie =",i,"\n")
# pegar a coluna correspondente a especie da vez
# definir o ano da vez
for(j in 1:1) {
cat("ano =",j,"\n")
cy <- yearl[j] # "cy" = "current year"
# definir o grupo da vez
for(k in 1:ngroups) {
cat("\nespecie = ", i, "\nano = ", j, "\ngrupo =",k,"\n", "\n-------------")
cg <- sitegroup[[k]] # "cg" = "current group"
# definir datas correspondentes ao grupo e ano da vez:
cdg <- sort(unique(datel[which(SEGMTS$Spot%in%cg & format(datel,'%Y')==cy)])) # "cdg" = "current day group"
# pular para o proximo grupo se nao houver dias amostrados no "cy":
if(length(cdg)==0) next
# calcular o fdc (first day column), ou seja, a primeira coluna a ser
# preenchida (referente ao primero dia daquele ano):
if(j==1) { fdc <- 1 } else { fdc<-sum(maxdy[1:(j-1)])+1 }
# guardar as datas em "DATSG":
if (i == 1) { # se for o loop da primeira especie
DATSG[fdc:(fdc+length(cdg)-1),k] <- cdg
}
# guardar o esforco e o numero de deteccoes, respectivamente,
# nas matrizes de esforco e no NDETSG:
for(l in 1:length(cdg)) {
cd <- cdg[l] # "cd" = "current day"
# guardar esforco em minutos em "EFFGmins":
EFFGmins[k,(fdc+l-1)] <- length(which(SEGMTS$Spot%in%cg & datel==cd))
# guardar esforco em numero de sitios em "EFFGsits":
EFFGsits[k,(fdc+l-1)] <- length(unique(SEGMTS$Spot[which(SEGMTS$Spot%in%cg & datel==cd)]))
# guardar o numero de deteccoes em NDETSG:
ndet <- sum(datel==cd & SEGMTS$Spot%in%cg & Y[,i]>thr,na.rm=TRUE)
NDETSG[k, fdc+l-1, i] <- ndet
} # l dates
} # k sites
} # j years
} # i species
head(NDETSG[,,1])
dim(sitegroup)
length(sitegroup)
head(sitegroup)
